---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT RULES &amp; GUIDELINES
<headers/>

## TECH STACK
*   Go (version 1.25 or later). Use any new features if applicable.
*   Temporal.io Go SDK
*   Bubbletea TUI Framework
*   Charmbracelet Lipgloss

## PROJECT DOCUMENTATION &amp; CONTEXT SYSTEM
*   The project includes comprehensive documentation.
*   Use code comments and descriptions to clearly explain the purpose and function of different code sections.
*   Keep documentation up-to-date with any changes to the codebase.
*   Aim for 100% code coverage.

## CODING STANDARDS
*   Follow Go coding conventions and best practices.
*   Write clean, modular, and well-documented code.
*   Use descriptive names for variables, functions, and methods.
*   Adhere to the project's architectural principles, emphasizing separation of concerns and domain-driven design.

## WORKFLOW &amp; RELEASE RULES
*   All code changes must be reviewed before being merged.
*   Implement comprehensive unit and integration tests for all new features.
*   Add a Codecov CI configuration. The `CODECOV_TOKEN` is in place.
*   Add a `make install` command that installs the library globally in a writable directory that's in the PATH.
*   Add a `make build` command.

## DEBUGGING
*   Use logging and debugging tools to identify and resolve issues.

## TUI DESIGN PRINCIPLES
*   The TUI should be aesthetically pleasing and easy to navigate.
*   Use clear and concise language in the user interface.
*   Provide helpful tooltips and documentation to guide users.
*   When implementing the TUI, make sure to use a modern aesthetic design with better colors, borders, and visual hierarchy. Aim for a beautiful theme system with a modern aesthetic (Catppuccin-inspired).
*   Redesign the TUI with stunning visuals: header, footer, borders, gradients.

## ERROR HANDLING
*   Implement robust error handling to prevent unexpected crashes.
*   Log errors and provide informative error messages to the user.

## CODE ANALYSIS
*   During the code analysis phase, focus on identifying Temporal workflows and activities.
*   The tool should identify:
    *   Workflows
    *   Activities
    *   Signals
    *   Queries
    *   Updates
    *   Timers
    *   Versioning
    *   Search Attributes
    *   Continue-as-New
*   During the code analysis phase, focus on identifying Temporal workflow and activity calls within a function.

## DEPENDENCY MANAGEMENT
*   Use Go modules to manage project dependencies.
*   Keep dependencies up-to-date.

## EXPORT FUNCTIONALITY
*   The tool should be able to export the analysis in multiple formats, including:
    *   JSON
    *   DOT (Graphviz)
    *   Mermaid
    *   Markdown

## NAVIGATION
*   Ensure the TUI navigation flow is intuitive.
*   When viewing a node's details and pressing Enter on an internal call, dynamically parse the source file at runtime to find what functions that internal call invokes. Only attempt to navigate to local functions.

## FILTERING
*   In the list view, initially prioritize showing only top-level workflows (those with no parents).
*   The initial view should only show top-level workflows from the tree.
*   The initial view should only show top-level workflows from the tree.
*   Provide options to toggle the visibility of activities, signals, and other components.
*   The `/` search function should not shift the layout down and should react to typing.
*   When a filter is active, it should be visually clear in the TUI.

## INTERNAL CALLS
*   The tool should also track "internal" non-Temporal function calls within Activities
*   The TUI should display Internal Calls, and also enable drill-down navigation into those function definitions
*   The TUI should also show "calls" and "called by" in the details view.
*   The details view should always show "Calls" and "Called By" sections, even if they're empty

## THEME
*   Follow the defined theme.

## GENERAL BEHAVIOR
*   The TUI should also show "calls" and "called by" in the details view.
*   The details view should always show "Calls" and "Called By" sections, even if they're empty
*   The TUI should also show "calls" and "called by" in the details view.
*   The list view should only show top-level workflows from the tree.

## GENERAL NOTES
*   Add new views: Stats dashboard, Graph visualization, Help overlay.
*   Implement a keyboard shortcut system with a help panel.
*   Add workflow search with fuzzy matching.
*   Create export functionality (DOT, Mermaid, Markdown).
*   The tool should be able to export the analysis in multiple formats, including DOT (Graphviz), Mermaid, and Markdown.
*   The TUI should be aesthetically pleasing and easy to navigate.
*   Use clear and concise language in the user interface.
*   Provide helpful tooltips and documentation to guide users.
*   Implement robust error handling to prevent unexpected crashes.
*   Log errors and provide informative error messages to the user.
*   In the details view, show internal calls (non-Temporal function calls) within Activities.
*   In the tree view, provide options to group the workflow by package or call hierarchy.
*   In the tree view, show internal calls (non-Temporal function calls) within Activities.
*   In the tree view, provide options to group the workflow by package or call hierarchy.
*   In the tree view, "by package" should use FQNs (grouping by common parent), otherwise it's too many.
*   Implement an optional positional argument for specifying the path of the project to scan. If not specified, defaults to the current working directory. This is an easier alternative to the `--root-dir` flag.

## CI/CD INTEGRATION
*   Implement a "lint" mode to use the analyzer in CI/CD pipelines. This mode should run non-interactively and report issues/violations in a CI-friendly format that could fail a CI build.
*   **Lint Mode** - Non-interactive analysis with exit codes for CI
*   **Multiple Formats** - Text, JSON, GitHub Actions, SARIF, Checkstyle
*   **Configurable Rules** - Enable/disable specific checks
*   **Strict Mode** - Fail on warnings for strict pipelines
*   **Code Fix Suggestions** - Include code fix suggestions in JSON and SARIF output formats. These can be used by:
    *   **GitHub Code Scanning** - SARIF format includes fixes that GitHub can display
    *   **IDE integrations** - JSON output includes fix suggestions for editor plugins
    *   **Custom tooling** - Parse the JSON/SARIF output to apply fixes programmatically

## LINT RULES
*   Every rule description should describe the real value—explain why we are checking these things in the first place.

## RULE DESCRIPTIONS
*   **ActivityWithoutRetryRule (TA001)**: Network blips, service restarts, and temporary unavailability are common. Without retry policies, every transient error becomes a workflow failure requiring manual intervention.
*   **ActivityWithoutTimeoutRule (TA002)**: Activities can hang forever due to deadlocked connections, infinite loops, or unresponsive dependencies. Without timeouts, workflows get stuck permanently, consuming resources and blocking business processes.
*   **LongRunningActivityWithoutHeartbeatRule (TA003)**: Long-running activities should have heartbeats. Without them, if a worker dies (OOMKill, scale-down, SIGKILL), Temporal must wait for the full timeout before retrying. Heartbeats enable fast failure detection.
*   **CircularDependencyRule (TA010)**: Workflow A waiting for B while B waits for A creates a deadlock that never resolves. These are hard to debug in production, waste resources, and can cascade into system-wide issues.
*   **OrphanNodeRule (TA011)**: Unused workflows/activities add maintenance burden, confuse developers, and may indicate incomplete migrations or forgotten features. Dead code should be removed to keep the codebase clean.
*   **HighFanOutRule (TA020)**: High fan-out creates blast radius issues: one change affects many dependencies. It makes testing harder, increases coupling, and often indicates a missing abstraction layer or orchestration pattern.
*   **DeepCallChainRule (TA021)**: Deep call chains make stack traces hard to read, increase end-to-end latency, and make it difficult to understand the business flow. Consider flattening or using child workflows for clarity.
*   **WorkflowWithoutVersioningRule (TA030)**: Long-running workflows may execute for days or weeks. Without versioning, deploying logic changes can break in-flight executions mid-run, causing failures and data inconsistencies.
*   **SignalWithoutHandlerRule (TA031)**: Unhandled signals are silently dropped. External systems sending signals believe they're communicating with the workflow, but the data goes nowhere—a silent failure that's hard to debug.
*   **QueryWithoutReturnRule (TA032)**: Queries exist so external systems can inspect workflow state without affecting execution. A query that returns nothing defeats its purpose and leaves callers without the insight they need.
*   **ContinueAsNewWithoutConditionRule (TA033)**: Without termination conditions, continue-as-new workflows run forever, accumulating costs and never completing. Every long-running workflow should have a defined end state or maximum iterations.

## GENERAL NOTES
* Record and render a terminalizer demo.
* Implement an optional positional argument for specifying the path of the project to scan. If not specified, defaults to the current working directory. This is an easier alternative to the `--root-dir` flag.
* Upgrade to Go 1.25 (or latest stable) and update go.mod
* Add Codecov CI config with GitHub Actions workflow
* Create Makefile with build, install, and test targets
* Implement Go 1.25 style optimizations
* Update the README with installation instructions and usage examples.
* **Positional Argument** - The path argument can now appear **anywhere** in the command line. The argument is extracted before flag processing and is used if the `--root` flag is not explicitly set.